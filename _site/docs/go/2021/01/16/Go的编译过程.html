<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/assets/css/style.css?v=">

<!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Go的编译过程</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="Go的编译过程" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="【学习笔记】Go的编译过程" />
<meta property="og:description" content="【学习笔记】Go的编译过程" />
<link rel="canonical" href="http://localhost:4000/docs/go/2021/01/16/Go%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.html" />
<meta property="og:url" content="http://localhost:4000/docs/go/2021/01/16/Go%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.html" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-01-16T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Go的编译过程" />
<script type="application/ld+json">
{"datePublished":"2021-01-16T00:00:00+08:00","dateModified":"2021-01-16T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/docs/go/2021/01/16/Go%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.html"},"description":"【学习笔记】Go的编译过程","url":"http://localhost:4000/docs/go/2021/01/16/Go%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.html","headline":"Go的编译过程","@type":"BlogPosting","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  </head>

  <body>

    <header>
      <div class="container">
        <a id="a-title" href="/">
          <h1></h1>
        </a>
        <h2></h2>

        <section id="downloads">
          
          <a href="" class="btn btn-github"><span class="icon"></span>View on GitHub</a>
        </section>
      </div>
    </header>

    <div class="container">
      <section id="main_content">
        <small>16 January 2021</small>
<h1>Go的编译过程</h1>

<p class="view">by </p>

<h1 id="学习笔记go的编译过程">【学习笔记】Go的编译过程</h1>

<h5 id="前导知识编译原理计算机组成原理">前导知识：编译原理、计算机组成原理</h5>

<h2 id="几个概念">几个概念</h2>

<h3 id="ast抽象语法树abstract-syntax-tree">AST抽象语法树（Abstract Syntax Tree）</h3>

<p>为了消除代码中无用的注释、空格等符号，编译器的主流方法是将代码的<strong>语法元素</strong>以树的形式存储起来</p>

<p>对于表达式<code class="language-plaintext highlighter-rouge">a*b+c</code>，可以表示为：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    +
   / \
  *   c
 /\
a  b
</code></pre></div></div>

<h2 id="静态单赋值static-single-assignmentssa">静态单赋值（Static Single Assignment，SSA）</h2>

<p>中间表示（Intermediate Representation，IR）：编译器或虚拟机（这里特指java虚拟机一类的虚拟机），使用的内部代码或数据结构，它可以用来做一些<strong>编译优化</strong>后生成<strong>更高效的目标代码</strong>。</p>

<blockquote>
  <p>A “good” IR must be <em>accurate</em> – capable of representing the source code without loss of information – and <em>independent</em> of any particular source or target language</p>
</blockquote>

<p>静态单赋值是GO语言的中间代码的一种特性</p>

<p>对于任何具有这种特性的中间代码，每个变量只会被赋值一次。</p>

<p>以下实例将展示SSA生成的中间代码的效果:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">:=</span> <span class="m">1</span>
<span class="n">x</span> <span class="o">:=</span> <span class="m">2</span>
<span class="n">y</span> <span class="o">:=</span> <span class="n">x</span>
</code></pre></div></div>

<p>经过简单的分析，可以发现第一行代码是无用的。</p>

<p>因此，我们通过用<strong>下标实现</strong>SSA的方式来对这段程序进行优化：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>x_1 = 1
x_2 = 2
y_1 = x_2
</code></pre></div></div>

<p>生成机器码时，编译器可以轻松的发现<code class="language-plaintext highlighter-rouge">x_1</code>与后面的代码执行没有任何关系，便可以在生成机器码时省略<code class="language-plaintext highlighter-rouge">x:=1</code>的赋值，通过减少需要执行的指令优化这段代码。</p>

<h3 id="指令集">指令集</h3>

<p>macos在命令行输入<code class="language-plaintext highlighter-rouge">uname -m</code> 即可查看当前机器的架构信息。</p>

<p>对于指令集，大概可以分为两类：</p>

<ul>
  <li>CISC复杂指令集：通过增加指令的类型减少需要执行的指令数。</li>
  <li>RISC精简指令集：通过使用更少的指令类型完成目标的计算任务。</li>
</ul>

<h2 id="编译原理">编译原理</h2>
<p>编译原理的四个阶段：</p>
<ul>
  <li>词法分析、语法分析</li>
  <li>类型检查</li>
  <li>AST语义树转换成中间代码、SSA生成（静态单赋值）,即编译优化阶段</li>
  <li>生成机器码<code class="language-plaintext highlighter-rouge">0101010</code></li>
</ul>

<h3 id="词法和语法分析">词法和语法分析</h3>

<h4 id="词法分析-lexical-analysis">词法分析 lexical analysis</h4>
<p>所有的编译过程都是从解析源代码开始的，词法分析(lexical analysis),其作用就是就是解析源代码文件，将文件中的字符串序列转换成Token序列，方便后面的处理和解析。</p>

<h4 id="语法分析-syntactic-analysis">语法分析 syntactic analysis</h4>
<p>语法分析输入的是词法分析输出的Token序列，语法分析会按照顺序解析Token序列，该过程会将词法分析生成的Token按照编程语言定义好的<strong>语法</strong>，被归纳成一个SourceFile结构参照<a href="https://golang.org/ref/spec#Source_file_organization">Go语言规范</a>：</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">SourceFile</span> <span class="o">=</span> <span class="n">PackageClause</span> <span class="s">";"</span> <span class="p">{</span> <span class="n">ImportDecl</span> <span class="s">";"</span> <span class="p">}</span> <span class="p">{</span> <span class="n">TopLevelDecl</span> <span class="s">";"</span> <span class="p">}</span> <span class="o">.</span>
</code></pre></div></div>

<ul>
  <li>词法分析器会返回一个不包含空格、换行符的Token序列</li>
</ul>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">"json.go"</span><span class="p">:</span><span class="w"> </span><span class="err">SourceFile</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"PackageName"</span><span class="p">:</span><span class="w"> </span><span class="s2">"json"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"ImportDecl"</span><span class="p">:</span><span class="w"> </span><span class="p">[]</span><span class="s2">"Import"</span><span class="p">{</span><span class="w">
        </span><span class="s2">"io"</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="nl">"TopLevelDecl"</span><span class="p">:</span><span class="w"> </span><span class="s2">"..."</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>
<ul>
  <li>语法分析器将上述词法分析器产生的Token序列，转化成抽象语法书AST，
每个AST对应单独的Go语言文件，AST中将会包含
    <ul>
      <li>当前文件的包名(package)</li>
      <li>定义的常量(const)</li>
      <li>结构体(struct)</li>
      <li>函数(func)</li>
      <li>…</li>
    </ul>
  </li>
  <li>语法分析器还会检查源文件中的<strong>语法错误</strong>，并将消息打印到标准输出，然后中止编译过程</li>
</ul>

<h3 id="类型检查">类型检查</h3>
<p>类型检查的将在语法分析完成后进行，
编译器将对语法分析器输出的AST进行分析：</p>
<ol>
  <li>常量、类型和函数名及类型</li>
  <li>变量和赋值和初始化</li>
  <li>函数和闭包<code class="language-plaintext highlighter-rouge">{}</code>的主体</li>
  <li>哈希键值对的类型（map类型的key<strong>不能是引用类型</strong>）</li>
  <li>导入函数体</li>
  <li>外部的声明</li>
</ol>

<p>要做到如上几点，我们只需要遍历整棵AST即可
我们对当前子树的类型进行验证操作，所有的类型错误和不匹配将在这个阶段被暴露出来，包括<strong>结构体对于接口的实现</strong>。</p>

<p>这边要提到一些go语言的特色，比如
<code class="language-plaintext highlighter-rouge">make()</code>方法，它将在这个阶段根据其被传入的类型，被展开成</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">runtime</span><span class="o">.</span><span class="n">makechan</span><span class="p">()</span>
<span class="n">runtime</span><span class="o">.</span><span class="n">makeslice</span><span class="p">()</span>
<span class="n">runtime</span><span class="o">.</span><span class="n">makemap</span><span class="p">()</span>
</code></pre></div></div>
<p>等工厂方法</p>

<h3 id="中间代码生成">中间代码生成</h3>
<p>在得到了语法分析器解析并通过类型检查后的AST被 <code class="language-plaintext highlighter-rouge">cmd/compile/internal/gc.compileFunctions</code>
我们知道go有go程（goroutine），而编译过程则是多个go程消费带锁队列（存放各个函数的AST）的<strong>并发过程</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>functions AST --&gt; |  ASTs Queue | --&gt; multiple Goroutines
</code></pre></div></div>
<p>因此，go的中间代码的编译过程，是并发进行的。</p>

<h3 id="机器码生成阶段">机器码生成阶段</h3>



  <small>tags: <em>programming</em> - <em>go</em> - <em>compiler</em></small>


      </section>
    </div>

    
  </body>
</html>
