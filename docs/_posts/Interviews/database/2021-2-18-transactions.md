---
layout: post
categories: database
title: "事务"
author: noobi
---

# 事务隔离

### 事务四大特性ACID

- Atomicity
- Consistency
- Isolation
- Duration

### 隔离性与隔离级别

#### 事务并发问题

- 丢失修改：事务修改数据，提交前，另一事务覆盖了之前的修改。
- 脏读（Dirty Read）：一事务修改但没有提交，另一个事务读取了，造成两个事务数据不一致。
- 不可重复读（Nonrepeatable Read）：在同一事务中，某查询操作在一个时间读取后，再次读取（中间没有修改），两次读取结果不一致（针对**update**）。
- 幻读（Phantom Read）：同一查询多次进行，由于其他事务在这个数据范围内进行了插入（针对**insert**），导致每次返回不同数目的结果集。



#### 四大隔离级别

- 未提交读（Read Uncommited）：在事务提交之前，执行结果对其他事务可见。
  - 最基本的级别，引发脏读、不可重复读、幻读。
- 提交读（Read Commited）：事务只能看见其他事务提交后的对表的修改。
  - 解决：脏读
- 可重复读（Repeatable Read）：确保同一事务在多次读取同样的数据时得到相同的结果。（MySQL默认隔离级别）
  - 解决：不可重复读，丢失修改（巧妙实现）
- 可串行化（Serializable）：强制事务串行执行，使之不能相互冲突，解决幻读问题。
  - 解决：幻读（很少使用，性能太差）

> 以上隔离级别，越往后，理论上并发度越低，性能越差



### MySQL如何实现隔离级别

数据库只要创建一个视图，访问以视图的逻辑结果为准，即可实现。

> 视图是从基本表通过查询选取出来的数据组成的**虚拟表**（数据库指存放视图的定义）。
>
> 视图保证了数据的安全性，简化了复杂的SQL操作，并能用于实现事务隔离。

- 读未提交：直接返回记录上的最新值。
- 读提交：每个SQL语句开始执行时创建。
- 可重复读：事务启动时创建视图。
- 串行化：直接加锁。

#### 可重复读如何实现？

前面看到，MySQL可重复读还可以解决**丢失修改**的问题，这离不开其中的巧妙设计。

MySQL中每条记录更新时，都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，可以得到前一状态的值。

undo log如下：

![d9c313809e5ac148fc39feff532f0fee](/assets/interviews/database/mvcc.png)

可以看到，同一条记录在数据库中可以有不同的 read-view读出不同的记录。

这涉及到MySQL的多版本并发控制MVCC，先按下不表。

但是基于undo log，MySQL可以实现多个视图的可重复读，并保证最终结果的一致性。

undo log 不能太长，因此MySQL会在**没有事务开视图指向undo log时，undo log会被剪短。**

因此，长事务不被推荐，因为它会使undo log又臭又长。