---
layout: post
categories: database
title: "MySQL数据库的索引"
author: noobi
date: 2021-01-28
---

# MySQL数据库的索引



## 什么是索引？

索引的存在就是为了提高查询效率，就好比**书籍的目录**一样。

## 索引的常见模型

- 哈希表（Key-Value）
  - 哈希冲突-拉链（链表法解决）
  - **区间查询**的效率极低，因为哈希函数算出的哈希桶位置**不能保证有序**
  
- 平衡树

  - AVL树

    AVL树是一种自平衡树，它需要维护每个节点的子树的平衡关系，作为平衡操作的依据。

    这种做法会消耗大量空间

    但是由于严格达到左右子树高度差不超过1，因此查询效率较高

  - 红黑树

    红黑树也是一种自平衡树，它的要求比AVL树更加宽松，空间消耗较小（额外存红/黑信息）

    红黑树在大量插入删除的场景下性能表现较好，因为不需要多次做平衡调整

    查询场景不如AVL树（非数量级上的差距）

    

  - B树 

    **以上两种平衡树的缺陷是**

    1. **严格的BST，每层不能用更多的分支。**

    2. **对于范围查询的场景适应极差（比如要查询N个连续节点，要进行 NlogN次 IO操作 ）**

    那么针对1，B树应运而生，B树每层存多个节点，大大降低了查询的时间成本

    但是就像我们在counting sort的文章中说的，每个B树节点存着**带有下层指针有序数组**，当data的Key很大时，空间就浪费掉了。
    
    

  - B+ 树

    B+树优化了B树的缺陷，顺便把2.的坑给填了。

    **第一，B+树首先是优化了B树的缺陷，每个非叶子结点不存data，只有叶子结点存data**

    那么非叶子结点就用来做索引，比如索引为15的指针，指向的节点一定比15小

    再比如索引为15～30的指针，指向的节点，一定在 $$[15,30)$$ 区间内

    **第二，B+树解决了低效的范围查询的坑，**

    设计者用链表的形式将叶子结点**数据页**（一个数组内的数据）**有序地串在一起**

    > 那么如果某个子节点的大小大于一页，可能就会引发多次页错误，降低系统效率
    >
    > 因此B+树的树叉数目会根据操作系统的页大小灵活调整，比如linux默认页大小4KB

    - InnoDB的B+树

      InnoDB由于物理上采取聚簇索引（Clustered Index），理论上查询效率更高，因此会将Data直接存在树叶上

      对于其他二级索引，会存逻辑上的主键ID值

    - MyISAM的B+树

      MYISAM的B+树不是聚簇索引，因此理论上插入删除的效率更高，牺牲了查询效率（由于需要根据指针再进行IO操作）。

      这里叶子存的是指向Data的指针，而Data存在另一个文件中。

​    

## 索引的应用

### 回表

> 我们知道，当定义主键 $$ID$$ 后，再定义索引 $$k$$
>
> 会分别产生**两个索引树**
>
> 此时的真实数据将存储在**主键的索引树**下
>
> 而我们后来定义的索引$$k$$的索引树，将存储主键的值

当执行一条查询语句时，如

```mysql
select * from T where k between 3 to 5 
```

~~InnoDB引擎会做如下的事情（待定）：~~

1. 先去 k 的索引树寻找ID

2. 然后再回到主键ID的索引树下寻找对应的ID
3. ♻️循环直到between区间的所有数据被取出

这个过程中有从k索引树到主键索引树的对应跳转过程，这被称为**回表**

再深一步看，也就是从OS的视角，每一次回表，都对应一次**I/O操作**

这就导致查询效率大幅下降。



那么有没有可以优化的点呢？

我们首先需要明白索引失效的原因。

## 索引何时会失效？

- 仅有主键索引的情况下，存在"%"开头的LIKE语句；
- OR语句前后没有同时使用索引；
- 数据类型出现**隐式转化**（varchar不加单引号被转化成int）
- 多列索引，不满足最左前缀原则
- MySQL估计全表扫描比索引快，则不使用索引（表很小）





## 如何设计高效的索引？

### 覆盖索引

如果此时执行语句

~~~mysql
select ID from T where k between 3 and 5
~~~

由于ID是主键，ID已经在这颗索引树上了，因此可以直接提供查询结果，不需要回表。

我们称这种行为是为**覆盖索引**，这是一种对于回表的常见优化手段。



> 这里有一个Server层与引擎层区别：对于以上的SQL语句，
>
> 虽然引擎层是取到3～5的所有记录，
>
> 但是Server层则是认为只拿了两个记录，MySQL则认为扫描行数是2



#### 应用

假设市民表的定义：

```mysql
CREATE TABLE `tuser` (
  `id` int(11) NOT NULL,
  `id_card` varchar(32) DEFAULT NULL,
  `name` varchar(32) DEFAULT NULL,
  `age` int(11) DEFAULT NULL,
  `ismale` tinyint(1) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `id_card` (`id_card`),
  KEY `name_age` (`name`,`age`)
) ENGINE=InnoDB
```

这里定义了索引``name_age`` ，

它建立了一个冗余的索引树，用于应对对于姓名年龄的**高频请求**

这样就避免了回表





###  最左前缀原则

了解B+树的结构的话，你一定知道

>  B+树的叶子结点是以有序链表的形式串联起来的
>
> 这个有序链表是根据索引的字段顺序以字典序排序的

可以利用多列索引的左前缀

比如假如索引``(a,b,c)``

where语句中 出现``(a) or (a,b) or (a,b,c) ``都不会使得索引失效

比如 “张三” 前缀是 “张x”

这里有一个需求，要查所有姓张的人，可以这么写SQL

```mysql
where name like '张 %'
```

由于张姓的索引在引擎看来是连续地有序串在一起的。

只要查找到第一个符合条件的记录是ID3，

对B+树来说，所有张姓索引包含在ID3以后的索引，

只要然后向后遍历，直到不满足条件为止，就可以达成目的。





### 索引下推（index condition pushdown）

最左前缀原则可以用于在索引中完整地定位记录。

此时我有联合索引``(name, age)``

但是，如果我的条件变更为

~~~mysql
select * from T where name like '张%' and age = 10 and ismale=1
~~~

我们当然可以筛选出所有张姓记录

但是在扫描满足ismale=1的记录

假设我们查到第一个张姓ID是ID3

按照一般逻辑，由于判断超出了索引的定义，我们需要从ID3开始，

反复**回表**进行查询判断



在MySQL 5.6后，引入了**索引下推**这项优化，可以对索引包含的字段先进行判断，直接过滤掉不满足``age=10``的记录，**减少回表次数**

 

### 那些字段适合索引

- 某列经常被作为最大值或者最小值
- 经常被查询字段
- 经常用做表连接的字段
- 经常出现在ORDER BY / GROUP BY /DISTINCY 后面的字段



### 创建索引时需要注意什么

- 建立在小字段上，大文本和大文件建立索引会导致**大量页错误**

- 字段非空，NULL很难进行查询优化
- 数据密度大（重复值少）的字段作为索引



### 索引分类

- 普通索引
- 唯一索引 UNIQUE：索引列的值必须唯一，但允许有空值；
- 主键索引 PRIMARY KEY：必须唯一，不允许空值（是一种特殊的唯一索引；MySQL创建主键时默认为聚集索引，但主键也可以是非聚集索引）；
- 单列索引和多列索引/复合索引（Composite）：索引的列数；
- 覆盖（Covering）索引：索引包含了所有满足查询所需要的数据，查询的时候只需要读取索引而不需要回表读取数据；
- 聚集（Clustered）索引/非聚集索引：对磁盘上存放数据的物理地址重新组织以使这些数据按照指定规则排序的一种索引（数据的物理排列顺序和索引排列顺序一致）。因此每张表只能创建一个聚集索引（因为要改变物理存储顺序）。优点是查询速度快，因为可以直接按照顺序得到需要数据的物理地址。缺点是进行修改的速度较慢。对于需要经常搜索范围的值很有效。非聚集索引只记录逻辑顺序，并不改变物理顺序；
- 分区索引（？）
- 虚拟索引（Virtual）：模拟索引的存在而不用真正创建一个索引，用于快速测试创建索引对执行计划的影响。没有相关的索引段，不增加存储空间的使用

