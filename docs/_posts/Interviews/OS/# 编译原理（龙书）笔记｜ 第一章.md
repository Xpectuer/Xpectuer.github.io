# 编译原理（龙书）笔记 ｜ 第一章



## 概述

### 语言处理器概述

- 编译器
  - 源程序到目标程序
- 解释器
  - 源程序与用户输入 运行时解释到 目标程序
- JVM混合编译器
  - 编译器（javac）产出中间代码（byte code）
  - byte code输入到jvm解释执行（或是JIT（热点代码直接解释为机器码））

### 编译器的结构

- 分析（anlysis）部分（前端）
- 综合（synthesis）部分（后端）

~~~flow
st=>start: 字符流
ed=>end: 目标机器码
lex=>operation: 词法分析器
ss=>inputoutput: 符号流
sa=>operation: 语法分析
ast=>inputoutput: 语法树
sma=>operation: 语义分析
ast1=>inputoutput: 语法树
mcg=>operation: 中间代码生成器
mco=>inputoutput: 中间代码
opt=>operation: 机器无关代码优化器（可选）
mco1=>inputoutput: 中间代码
cgen=>operation: 代码生成器
tar=>inputoutput: 目标机器语言
mopt=>operation: 机器相关代码优化器（可选）
table=>operation: 符号表


st->lex->ss->sa->ast->sma->ast1(right)->mcg->mco->opt->mco1->cgen->tar->mopt->ed

~~~



### 程序设计语言基础

#### 1.6.1 静态与动态

- 编译期间决定的问题称为静态（static）策略
- 运行时期决定的问题称为动态（dynamic）策略

#### 1.6.2  环境与状态

- 简单来说，**环境**是指高级语言的变量与变量内存的位置的映射（variable : address）

- **状态**就是变量地址对应的值（address：value）

考虑以下C程序

~~~c
int i; /*global*/
void f() {
  int i; /*local */
  i=3; /*usage of local*/
}
...
x = i+1 /*global*/
~~~

可以理解为盗梦空间，**下层梦境与上层梦境无关**，但是上层梦境可以携带值进入下层梦境（这一点稍后讨论）

由于``f()``的入栈，变量``i``的符号不变，但是环境相应改变（栈中位置）。

因此``i=1``会使用``f()``中的``i``  

以上关于``f()``的描述，均是动态绑定。

我们需要了解的静态绑定：

1. C语言的全局变量可以在编译期间直接分配一个地址，但是不确定值。
2. C语言的宏定义常量在编译期间便确定了**地址和值**。

##### 一些实验：

我们对上述代码稍加修改，使得``f()``	传入一个参数。

~~~c
// filename: test.c
int i;
void  f(int i) {
    int i;
    i = 3;
}

int main(int argc, char** argv) {
    f(3);
    return 0;
}
~~~

``gcc test.c -o test``得到报错，可见编译器**不允许变量作用域的混淆**。

~~~shell
test.c:4:9: error: redefinition of 'i'
    int i;
        ^
test.c:3:13: note: previous definition is here
void  f(int i) {
            ^
1 error generated.
~~~



#### 1.6.3 静态作用域

C、C++、Java这些语言存在块结构{}，这些结构实质上是互相隔离的。

##### 块结构

>  注意⚠️： 在非函数式编程的语言中，块中不能定义其他 “**过程**”



那么问题来了，如果块内存在和块外相同名字的变量，该如何决定？



这很简单，任何块结构遵循**由内而外的思路，块与块之间的声明互不干涉**的规律。

用一个例子来说明：

~~~c
// filename: test_block.c
#include <stdio.h>

int main() {
    int a = 1;
    int b = 1;
    {
        int b = 2;
        {
            int a = 3;
            printf("a:%d b:%d\n",a,b);
        }
        {
            int b = 4;
            printf("a:%d b:%d\n",a,b);
        }
        printf("a:%d b:%d\n",a,b);
    }

    printf("a:%d b:%d\n",a,b);
    return 0;
}
~~~

我定义了很多块，输出一下定义的变量就可以验证上述规律。

```shell
$ gcc test_block.c -o block
$ ./block
a:3 b:2
a:1 b:4
a:1 b:2
a:1 b:1
```

#### 更多的静态声明方式

像java、C#这种OOP语言，可以通过``public private protected``显式地声明变量的作用域

如C++这种OOP语言，仍然拖着C的一些毛病，它支持了**类方法定义在方法外的声明方式**。如下所示，

```cpp
void A::dosth() {
  ...
}
```



#### 1.6.4 动态作用域

以下程序片段中，``a``被定义为宏，但是我们并不能确定``x``的值。

这时候就要用到**动态作用域**

规则是：**选择最近调用的但还没有终止且声明了x的过程的这个声明。**

比如一下程序，``a``在宏定义中被声明，但无法确定``x``	的值。

那么如何确定作用域呢？

1. 我们就需要检查所有被调用到a的函数
2. 随后选择当前的最近调用的函数栈，检查是否有``x``
3. 如果没有，去外部找。

 ```c 
#define a (x+1)
int x = 2; 
void b() { int x = 1; printf("b %d\n", a);}
void c() { printf("c %d\n", a);}
void main() {b(); c();}
 ```

~~~shell
$ gcc dynamic.c -o dynamic
$ ./dynamic
b: 2
c: 3
~~~

​    

##### 面向对象的多态举例

面向对象语言，比如Java，有多态的特性

> 所谓多态，就是能够在确定一个对象调用具体虚函数的情况下推断出其具体的实现，

以java为例，多态被分为：

1. 编译时多态：方法重载``overload``

   这是由于在编译后就能将方法根据方法签名（返回值、方法名、参数列表）区分开。

2. 运行时多态：方法重写``override``

   这是由于在编译期间，先递归查看父类有无这样的方法，直到Object都没有的话就报错

   随后在运行阶段（编译期间拿不到完整的类表），查看一下子类中是否存在覆盖方法，有则执行，如果没有则报错。

#### 1.6.4 参数传递

##### 值调用

​	所谓值调用，就是将传入**参数的拷贝**传入过程。

​	一般来说，可以认为值调用不会改变值本身。

 	实际上也有例外，当传值传递指针地址值时就会修改原值。

​	多写代码就会有直观的感受。

##### 引用调用

​		引用调用，即将参数的地址传入过程。

~~~cpp
void f(int &a);
~~~

​		这种方式解决了传入大型参数时，开销过大的问题。

##### 别名

当参数传引用时，两个参数可能指向同一对象，此时对一个参数的修改会影响到另一个参数。

编译器设计时可以设计warning、error或者优化。



 