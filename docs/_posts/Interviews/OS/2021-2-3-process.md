---
layout: post
categories: OS
author: noobi
date: 2021-02-03
---
# OS的进程

# 进程与线程

- 进程（process）是**操作系统资源分配和调度**的基本单位，
线程（Thread）是**CPU调度与分派**的**基本单位**

- 线程依赖于进程存在，一个进程至少有一个线程（主线程）

- 地址空间：进程有独立的**地址空间**，线程共享进程的地址空间

资源方面：
  - 进程：拥有独立的内存沙盒（text代码段、堆、栈、常量池等）
  - 线程：
    
    - **独立**的栈、PC和一组寄存器
    - **共享**内存（堆内存）、IO和CPU(运行必须)

上下文切换：
  - 进程的切换涉及到内存总线的交互，开销较大（更差的情况下会出现swapping）
  - 线程的切换在进程内完成，只涉及少量寄存器的内容

通信方面：
  - 进程的通信（IPC）分为：
    - 匿名管道：半双工，只能在具有亲缘关系（父子）的进程中
    - 命名管道：允许无亲缘关系的进程通信，半双工
    - 消息队列：消息的链表、可用于共享资源
    - Socket套接字（域、类型和协议）：值得一提的是，在IPC中，Linux会做优化，省略TCP以下层的开销
    - 信号量（计数器、锁机制）用于控制对于共享资源的访问
    - 信号（通知事件发生）
    - 共享内存
   - 线程的通信：
     - 线程的通信更加方便：由于在进程资源内完成
     - 共享资源（进程的公共变量）
     - Go语言中的Channel可以认为是消息队列的一种实现（带Mutex锁）（实际上Goroutine与线程又有本质上的区别）
        - 多线程程序只要有一个线程崩溃，整个进程就会崩溃，
        - 而多进程程序因为有独立的空间


### 线程

#### 共享资源

- 代码段
- 共有数据（全局变量、静态变量）
- 进程打开的文件描述符（File Handler）
- 进程的当前目录（pwd）
- 信号处理器/信号处理函数
- 进程ID与进程组ID

#### 独占资源

- 线程ID
- 线程独有的栈（而堆共享）
- 错误的返回码：线程可能会产生不同的错误返回码，一个线程的错误返回码不应该被其它线程修改
- 信号掩码（signal mask）：表示是否屏蔽/阻塞相应的信号

### 进程通信

  - 进程的通信（IPC）分为：
    - 匿名管道：半双工，只能在具有亲缘关系（父子）的进程中
    - 命名管道：允许无亲缘关系的进程通信，半双工
    - 消息队列：消息的链表、可用于共享资源
    - Socket套接字（域、类型和协议）：值得一提的是，在IPC中，Linux会做优化，省略TCP以下层的开销
    - 信号量Semaphore、PV操作：（计数器、锁机制）用于控制对于共享资源的访问
    - 信号（通知事件发生）
    - 共享内存


### 进程同步问题

> 进程同步是目的，进程间通信是实现同步的手段

#### 管程Monitor

定义一个第三方Moniter程序，封装共享内存以及对共享内存的操作。

进程互斥（exclusiely）地使用Monitor，使用完之后释放Monitor并唤醒入口队列的进程。

##### HOARE Monitor：

当一个进程试图进入Monitor时，在**入口等待队列**等待。若P进程唤醒了Q进程，则Q进程先执行，P在 **紧急等待队列**中等待。

wait操作：执行wait操作的进程进入**条件变量链**的末尾，唤醒紧急等待队列或者入口队列中的进程；signal操作：唤醒条件变量链中的进程，自己进入等待队列，若条件变量链为空，则继续执行。

##### MESA Monitor：

将HOARE的signal换成了notify（广播通知所有满足条件的进程），通知而不是立马交换Monitor的使用权，在合适的时候（比如monitor中的进程释放锁），条件队列首位的进程可以进入，进入之前必须用while检查条件是否合适。

优点：没有额外的进程切换。

#### 生产者消费者（Producer-Consumer）问题

> 问题描述：使用一个缓冲区来存放数据，
> 只有缓冲区没有满，生产者才可以写入数据；只有缓冲区不为空，消费者才可以读出数据

~~~cpp
// Semaphore
// full: number of items in buffer
// empty: number of spare places in buffer
// mutex
// semaphore 0: block; 
// semaphore > 0: pass; 
semaphore full=0, empty = n, mutex = 1;

// Producer
void produce() {
    while(true) {
        P(empty);
        P(mutex);

        // do produce...

        V(mutex);
        V(full);
    } 
}

void consume() {
    while(true) {
        P(full);
        P(mutex);

        // do consume...

        V(mutex);
        V(full);
    }
}

```
~~~

#### 哲学家就餐

> 问题描述：有五位哲学家围绕着餐桌坐，每一位哲学家要么思考，要么吃饭。为了吃饭，哲学家必须拿起两双筷子（分别放于左右两端）不幸的是，筷子的数量和哲学家相等，所以每只筷子必须由两位哲学家共享。

~~~cpp
#define N 5  // number of philosopher
#define LEFT (i + N - 1)%N // number of i's left neighbors
#define RIGHT (i + 1)%N // number of i's right neighbors
#define THINKING 0
#define HUNGRY 1
#define EATING 2

typedef int semaphore;

int state[N];// array to keep track of everyone's state. init: THINKING
semaphore mutex = 1; 
semaphore s[N];// array to record everyone's semaphore. init: 0

void pholosophers(int i) {
    while(true) {
        think();
        take_forks(i);
        eat();
        put_forks(i);
    }
}

void take_forks(int i) {
        P(&mutex); // critical region
        state[i] = HUNGRY; // record that i is hungry
        test_forks(i); // attempt to acquire two forks
        V(&mutex); // exit critical region
        P(&s[i]); // block if forks are not acquired
}

void put_forks(int i) {
        P(&mutex); // enter critical region
        state[i] = THINKING; // finished eating
        test_forks(LEFT); // see if left neighbor is now eating
        test_forks(RIGHT); // see if right neighbour is now eating
        V(&mutex)
}

void test_forks(int i) {
    // see if left and right fork are being used
    if(state[i] == HUNGRY && state[LEFT] != EATING && state[RIGHT] != EATING) {
        state[i] = EATING;
        // release the s
        V(&s[i]);
    }
}

~~~

#### 读写问题

> The simplest one, referred to as the first readers–writers problem, requires that no reader be kept waiting unless a writer has already obtained permission to use the shared object. 

~~~cpp
semaphore rw_mutex = 1;
// used to lock the read_count variable
semaphore mutex = 1;
// shared var
int read_count;

void write() {
    while(true) {
        P(&rw_mutex);
        // do write
        // ...
        V(&rw_mutex);
    } 
    
}

void read() {
    while(true) {
        P(&mutex);
        read_count++;
        if(read_count == 1)
            P(&rw_mutex);
        V(&mutex);

        // do reading
        // ...

        P(&mutex);
        read_count--;
        if(read_count==0) 
            V(&rw_mutex)
        signal(&mutex)
    }
}

~~~


#### 临界区
各个进程对临界资源（互斥资源/共享变量，一次只能单个进程独占）进行操作对代码片段

#### 同步与互斥
- 同步：多个进程因为合作而使得进程的执行有一定的先后顺序。比如某个进程需要另一个提供的消息，获得消息前进入阻塞态（e.g.: go channel）；


- 互斥：多个进程在同一时刻只有一个进程能够进入临界区（e.g.: mutex）。

#### 操作系统的进程状态

- New: 进程被创建
- Ready：进程获得除了CPU（处理机）外的所有所需资源，等待分配CPU资源
- Running：进程占用CPU资源运行，处于此状态的进程数不可能大于CPU数
- Waiting: 进程等待某条件，条件满足前无法执行（比如IO的完成）
- Terminated：进程结束执行
  

![states](/assets/interviews/os/states.png)

### 进程调度策略
1. 批处理系统（Batch System）
   1. FCFS先来先服务
   2. SJF最短作业优先
   3. 最短剩余时间优先（SRTN shortest remaining time next）
   4. 最高相应比优先吧 (HRRN Highest Response Ratio next)
      1. Response Ratio = (W+S)/S
         1. W -> Waiting time
         2. S -> Service or Burst Time

2. 交互式系统

> 交互式系统允许多用户多进程，设计目标是快速相应
    1. Round Robin
    2. Priority Scheduing
    3. Multilevel Feedback Queue

#### 优先级反转？如何解决

高优先级的进程被一个低优先级的进程占用共享资源，就会出现优先级反转，  
即**低优先级进程先与高优先级进程执行**。

解决方案：
   - Priority Ceiling：当任务申请某资源时，把该任务优先级提升到可访问这个资源的所有任务中的**最高优先级**。简单易行
   - Priority Inheritance：
     - 任务A申请共享资源S时，如果任务C的优先级小于自身的优先级，则将任务C的优先级提升到自身的优先级，任务C释放资源S后，释放任务C的优先级。

#### 僵尸进程🧟‍♂️Linux

子进程结束后，父进程没有调用wait() / waitpid() 为其**收尸**，则子进程将成为**僵尸进程**。僵尸进程是一个已经死亡了的进程

**僵尸进程的特点**

🈚️：

- 放弃几乎所有内存空间（除了下面的内容）
- 无可执行代码
- 不能被调度

🈶️：

- 在进程表中的位置
  - PID
  - 终止状态
  - 资源利用信息
  - 除此之外，不占有内存空间

僵尸进程将一直在系统中，**直到系统重启。**

危害：

- 占用PID
- 占用内存



**不会产生僵尸进程的状况（避免僵尸进程）**：

- 父进程先结束，子进程成为**孤儿进程**，被init进程**收养**（adopt），init调用wait()等待其结束
- 父进程代码中调用wait() / waitpid() 等待子进程结束（定时轮询）。
  - wait()  ``wait(int *status)``会使父进程阻塞，直到任意一个子进程结束为止（触发收尸）。
  - waitpid()  ``wait(pid_t pid, int *status, int options)``  则可以加入``WNOHANG``(wait no hang)选项。
    - 如果没有发现结束的子进程，就会返回。**不会导致父进程阻塞**
    - waitpid几个模式，定制性较高
      - 等待任一子进程
      - 等待指定pid子进程
      - 等待同一个进程组下的任一子进程
- 子进程结束时，系统将会产生一个``SIGCHLD``（signal-child）信号
  - 可以注册一个handler信号处理函数，在该函数中调用``waitpid``，等待**所有结束的子进程**（需要用循环包起来，以此来处理多个结束的子进程）
  - 可以利用  ``signal(SIGCHLD, SIG_IGN)`` 通知内核，表示**父进程**忽略``SIGCHLD`` 信号，子进程结束后，内核进行回收。
- 孤儿进程
  - 父进程结束运行后，子进程依然运行，则称其为孤儿进程，它们会被init进程接管，结束时由init进程完成状态收集工作。



### 线程同步策略

> 线程同步是由于，线程有时与其他线程共享资源，比如内存、数据库等。
>
> 当多个线程同时读写一份共享资源时，会冲突。因此需要进程同步，多个线程按顺序访问资源。

- 互斥量Mutex（Mutually Exclusive ）：互斥量是内核对象。
  - Mutex只有一个，保证同时只有一个线程访问共享资源。
- 信号量Semaphore：信号量是内核对象。
  - 允许同时有多个线程访问共享资源，但是会控制同时访问的数量（Semaphore为0时不能访问）
  - 信号量保存了最大资源计数与当前可用资源计数。
  - 信号量取1时，等价于Mutex
- 事件Event：允许一个线程在处理完任务后，主动唤醒另一个线程执行任务。
  - **手动重置事件**：激发后，唤醒所有**等待的线程**，而且一直保持为激发状态，直到程序重新把它设置为未激发状态。
  - **自动重置事件**：设置为激发态后，唤醒一个等待中的进程，自动恢复为**未激发状态**。
- 临界区 Ciritical Section：任意时刻只允许**一个线程**对临界资源进行访问。拥有临界区对象的线程可以访问该临界资源，其他试图访问该资源的线程将被挂起，直到临界区对象被释放。



##### 互斥量与临界区的区别

互斥量可以被命名，可以用于不同进程间的同步；

临界区只能用于同一进程中的线程同步（执行同一片代码片）。

互斥量创建资源更多，临界区的优势是速度快，节省资源（增加编码调试的复杂度）。



### 协程Coroutine

是一种用户态的轻量级线程，协程的调度**完全由用户控制**。

协程讲求**异步思想** ，见异步IO操作

协程拥有自己的**register context和 栈**。

> 一个协程包含在一个线程中
>
> 一个线程可以包含多个协程，但是同时只能执行一个
>
> 因此不需要担心内存共享问题

协程调度切换时，将register context 和 栈保存到内存（往往很小）

切回时，恢复上下文和栈，这个过程不需要锁，非常快。

协程的优势（之一）：以同步的代码，完成异步回调的操作。

#### 协程与线程

- 一个线程可以拥有多个协程，一个进程也可以单独拥有多个协程。
- 线程进程都是同步机制，协程是一步
- 协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态。

##### 扩展：

[Goroutine模型介绍]()



### IO多路复用（IO Multiplexing）？如何实现？

[IO模型介绍](https://blog.csdn.net/qq_34638435/article/details/81878301)

[IO读写的两个阶段](https://www.yuque.com/banner/bc99qn/rk5k95)

IO多路复用指单个进程/线程就可以**同时处理多个IO请求**

原理：用户将需要监视的FD（File descriptor）添加到select/poll/epoll函数中，由内核监视，函数阻塞。

这些函数反复查询是否有FD就绪。

一旦有FD就绪（读就绪或写就绪）或超时（timeout），函数就会返回，然后进程/线程就可以进行读写操作。

#### IO multiplexing的函数

- ``select``：将所有FD（不管是否与用户有关）放入一个集合中，调用select时，将这个集合**整个拷贝入内核**（导致巨大开销），内核根据FD就绪状态修改该集合的内容。

  - 集合的大小有限制（32位机器默认是1024，64位机器默认2048）。

  - 采用**水平触发机制**
  - 返回后，需要遍历集合，找到就绪的FD（时间复杂度高），FD数量增加，效率则线性下降。

- ``poll`` 和``select``几乎没有区别，优化的点是将集合做成了**链表**，没有储存数量上限。

- ``epoll`` ：内核与用户空间共享内存，避免了不断复制的问题；

  - 支持同时连接数很高（1G内存支持10W左右的连接）
  - FD就绪时，采用**回调机制**，避免了轮询（回调函数将**就绪的描述符**添加到一个链表中，执行``epoll_wait``时返回这个链表）
  - 支持**水平触发和边缘触发**（采用**边缘触发**时，只有**活跃的描述符**才会触发回调）

以上，主要区别在于：

- 最大连接数
- FD的传递方式
- 水平触发 / 边缘触发
- 就绪时查询FD的效率（是否为轮询）

##### 应用场景

当连接数较多，并且有很多不活跃的连接时，``epoll``效率明显高于前两者

当连接较少，并十分活跃时，``epoll`` 的反复回调会造成性能下降

##### 文件描述符File Descriptor(FD)

文件描述符是一个指针，形式上是一个非负整数。

FD指向内核为每个进程维护的 **文件记录表**。

当程序打开一个现有文件或者创建新文件时，内核向进程返回一个FD指针。

FD指向一个文件。

##### 水平触发 / 边缘触发

- 水平触发（LT，Level Triggered），只要有FD就绪，就会触发通知，只要没读完，就会反复通知用户。
  - 优点：保证了数据输出的完整，编码简单
  - 缺点：IO较为密集的场景，会导致大量地从用户态到内核态到切换，会浪费资源，降低效率。
- 边缘触发（ET，Edge Triggered），只支持非阻塞式的IO，仅当FD就绪时通知，通过``epoll`` 通知用户，仅通知一次。
  - 优点：每次内核只会通知一次，大大减少了内核资源的浪费。
  - 缺点：不能保证数据的实时完整性。不能及时的取出所有的数据。
- 区别：边缘触发的效率更高，减少了被重复触发的次数，函数不会返回大量用户程序可能不需要的FD。
- 为什么边缘触发只能用于**非阻塞式IO(non-block IO)**：
  - 避免由于一个描述符的阻塞读/阻塞写让其他FD出现饥饿状态。
  - 当阻塞读/写时，data较大，其他的FD将会一直无法被读写



### 常见的IO模型

1. 同步阻塞式IO：发起IO操作后，线程阻塞，直到可以开始处理数据。
2. 同步非阻塞式IO：发起IO请求可以立即返回，如果没有就绪的数据，需要不断发起IO请求知道数据就绪；重复请求会消耗大量CPU资源
3. IO多路复用
4. 异步IO（Asynchronous IO）：发出IO请求后，继续执行，由内核进行数据读取并放在用户指定的缓冲区中，在IO完成后通知用户线程直接使用。

- 除了异步IO，其他所有的IO模型都会在数据从内核拷贝到用户内存的过程中阻塞线程。

### 用户态和内核态

为了限制不同程序的访问能力，防止一些程序访问其它程序的内存数据，CPU划分了用户态和内核态两个权限等级。

- 用户态只能受限地访问内存，且不允许访问外围设备(periphery device)，没有占用CPU的能力，CPU资源会被动地被切换夺走。
- 内核态可以访问内存所有数据以及外围设备，也可以进行程序的切换。

所有用户程序都运行在用户态，但有时需要进行一些内核态的操作，比如从硬盘或者键盘读数据，这时就需要进行系统调用，使用**陷阱指令**，CPU切换到内核态，执行相应的服务，再切换为用户态并返回系统调用的结果。



#### 分用户态和内核态的目的

- 安全性：防止恶意程序破坏系统/内存/硬件资源；
- 封装性：用户不需要实现底层代码。
- 利于调度：多个用户程序都在等待键盘输入，此时就需要进行调度；统一交予OS调度更加方便。

#### 如何从用户态切换到内核态

- 系统调用：本质是通过中断interrupt实现
- 发生异常，比如缺页异常page error
- 外围设备中断：外围设备完成用户请求的操作后，CPU会收到中断信号，CPU此时处理中断处理程序。



### 死锁

**两个或者多个并发进程（>1）**中，每个进程持有某种资源又等待其他进程的资源释放，不改变这种状态前，不能向前推进。

#### 必要条件

- 互斥Mutual Exclusion：一个资源一次只能被一个进程使用
- 占用等待Hold and Wait：一个进程必须持有至少一个资源并等待其他被占用的资源被释放。
- 非抢占No Preemption：被占用的资源不能被强制性抢占，只能由进程完成任务后自愿释放。
- 循环等待Circular Wait：所有进程的资源依赖成环，环中的每个进程都在**占用等待**

#### 处理策略

- 鸵鸟策略：死锁影响较小，或者概率较低时，选择不处理死锁。

- 死锁预防prevention：基本思路是**破坏四个必要条件**

  - 互斥：允许某些资源同时被多进程访问	

    - 对资源本身限制较高，不具普适性

  - 占用等待：

    - 资源预先分配：一次性向系统申请它所需的全部资源，否则不运行（RAII）
    - 只允许进程在没有占用资源时申请资源（先释放后申请）
    - 无法预知进程所需的全部资源；会降低资源利用率

  - 非抢占：允许进程抢占。可能会造成饥饿。

  - 循环等待：对资源统一编号，所有进程请求必须按照编号递增的顺序提出。

    ​					即只有先占用编号较小 的资源才能申请编号较大的资源。

    ​					避免占有大号资源的进程去申请小号资源。

- 死锁避免avoidance

  ​	动态地检测资源分配状态，确保系统是**安全状态**。

  ​	只有不死锁时才会对资源进行分配

  > 安全状态：即使所有进程突然请求需要的所有资源，也能存在某种对进程的资源分配顺序，使得每一个进程运行完毕。

  ​	[银行家算法](https://www.cnblogs.com/wkfvawl/p/11929508.html#:~:text=%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E8%B4%A8,%E8%B5%84%E6%BA%90%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%B0%86%E9%98%BB%E5%A1%9E%E3%80%82)

- 死锁解除

  > 检测有向图是否存在环；或者使用类似于死锁避免的检测算法。

  死锁解除的方法：

  - 利用抢占：挂起进程，抢占资源。但是应防止某些进程被长时间挂起而处于饥饿状态。
  - 回滚：将进程会退到自愿释放资源。要求系统保持进程的历史信息（打桩），设置还原点。
  - 杀死程序：kill -9掉某些进程，按照优先级kill



### 分页和分段的区别

- **页式存储**：将用户空间划分为大小相等的部分(Linux默认4KB每页)，每页空间称作页框，分配时以页为单位，按照进程所需的页数分配，**逻辑上相邻的页物理上不一定相邻**（由页表决定）；
- **段式存储**：用户进程按照 堆栈段、静态数据、代码等划分为不同段，段内占据连续空间，段与段可以不相邻
- **段页式存储**：综合以上两种，先按照段划分，段内按照页划分。



#### 区别：

- 目的：
  - 分页是用于管理内存，减少内存碎片，并用于虚拟内存以获得更大的地址空间；
  - 分段则是方便用户，将程序和数据划分为逻辑上独立的地址空间。
- 大小：
  - 分页大小固定（可以被系统设置）
  - 分段不固定（堆栈增长、编译期间分配静态常量）
- 地址空间维度不同：
  - 分段是二维地址（段号+段内偏移）
  - 分页是一维地址（每个进程一个页表/多级页表，通过一个逻辑地址就能获得物理地址）
  - 分段便于信息的保护和共享（共享堆，不共享栈）；分页的共享受到限制；
  - 碎片：分段没有内碎片，但是产生外碎片；分页没有外碎片，可能产生内碎片（填不满一个页）



### 虚拟内存（Virtual Memory）

