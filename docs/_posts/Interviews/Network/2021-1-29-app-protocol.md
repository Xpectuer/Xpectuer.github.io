---
layout: post
title: "应用层协议"
tags: network interview
categories: interview
---





# 应用层协议

### HTTP和HTTPS有什么区别？

1. 端口不同：HTTP默认端口是80，HTTPS默认使用443端口

2. HTTP明文传输。

   HTTPS运行在SSL（Secure Socket Layer）层，添加了加密与认证机制，更加安全

3. HTTPS由于加密解密算法，对CPU开销更大
4. HTTPS通信需要证书，一般需要像CA购买。

#### HTTPS的连接过程（TLS握手）

1. 客户端向服务端发送请求，捎带客户端支持的一套加密规则（对称、非对称、摘要算法）；

2. 服务器从中选出一组加密算法和HASH算法

   将自己的身份信息以证书形式发回到客户端。

   证书内容包括：

   - 网站地址
   - 加密公钥（非对称加密）
   - 证书颁发机构（私钥用于服务端解密）

3. 客户端验证服务器端合法性，证书是否过期，CA是否可靠，发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配；

4. 浏览器生成一个 **随机密钥**（用于对称加密），并用服务器给的公钥对**随机密钥**加密（非对称算法）；使用Hash算法对**握手消息**进行**摘要计算**，并对摘要使用之前的密钥加密（对称算法）；将加密后的**随机密钥**和**摘要**一起发送给服务器；

5. 服务器使用自己的私钥解密**经过公钥加密的随机密钥**，得到**对称加密的密钥**，用这个密钥解密出Hash摘要值，并验证**握手消息**是否一致；如果一致，服务器使用对称加密的密钥握手消息发送给服务器。

6. 浏览器解密并验证摘要，若一致，则握手结束。之后的数据传送都使用**对称加密**的密钥进行加密。

- 非对称加密由于性能较差，用于加密对称加密的密钥
- 对称加密由于性能较好，但被窃取密钥后容易被推演，因此，与非对称算法配合使用，用于加密消息。
- HASH算法则是将较长的报文hash映射为短摘要，用于验证数据完整性。

#### 如何自动切换到HTTPS

- 302跳转，容易被中间人劫持
- HSTS( HTTP Strict Transport Security)服务端发送响应头加入STS信息，支持的客户端将强制使用https

#### HTTPS连接时，怎么确定收到的包是服务端发来的（中间人攻击）

客户端验证HTTPS服务端的证书信息。

#### 对称加密、非对称加密

- 对称加密：加密解密采用相同的密钥，缺点是密钥如果是明文传输极有可能被结获并解密信息。

  例如：DES、RC2、RC4

- 非对称加密：需要公钥和私钥。如果用公钥加密，需要用私钥才能解密。

  例如：RSA

- 区别对称加密速度更快，用于大量数据加密；

  非对称性能较差，但是安全性更高，常用于加密对称算法的密钥、签名等。



#### 数字签名、报文摘要

- 发送者A用私钥进行签名，接受者B用公钥验证签名。

  私钥仅仅由A保有，因此B可以相信签名来自A。

- 摘要算法：大致效果就是将长报文通过哈希映射为短串，可以加快验证速度，以验证报文完整性。

  例如：MD5、SHA



### GET与POST的区别

1. GET是**幂等**的，即读取同一个资源，总是得到相同的数据，POST不是幂等的；

> 某[一元运算](https://www.knowpia.cn/pages/一元運算)为**幂等**的时，其作用在任一元素两次后会和其作用一次的结果相同。例如，[高斯符号](https://www.knowpia.cn/pages/高斯符號)便是幂等的。

1. GET一般用于从服务器获取资源，而POST**有可能改变服务器**上的资源；
2. 请求形式上：GET请求的数据附在URL之后，在**HTTP请求头**中；POST请求的数据在**请求体**中；
3. 安全性：GET请求**可被缓存、收藏、保留到历史记录**，且其请求数据明文出现在URL中。POST的参数不会被保存，安全性相对较高；
4. GET**只允许ASCII字符**，POST对数据类型没有要求，也**允许二进制数据**；
5. GET的长度**有限制**（操作系统或者浏览器），而POST数据大小**无限制**



#### Session和Cookie的区别

由于http本身是无状态的，我们需要一个附加方案来保证状态

Session是**服务器端保持状态**的方案，Cookie是**客户端保持状态**的方案

Cookie保存在客户端本地，客户端请求服务器时会将Cookie一起提交；

Session保存在服务端，通过检索Sessionid查看状态。

保存Sessionid的方式可以采用Cookie，如果禁用了Cookie，可以使用**URL重写机制**（把会话ID保存在URL中）。



### 输入网址到获得页面的过程

1. 浏览器查询 **DNS**，获取域名对应的IP地址:具体过程包括浏览器搜索自身的DNS缓存、搜索操作系统的DNS缓存、读取本地的Host文件和向本地DNS服务器进行查询等。

   对于向本地DNS服务器进行查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析(此解析具有权威性)；

   如果要查询的域名不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析（此解析不具有权威性，**可能发生DNS劫持**）。

   如果本地域名服务器并未缓存该网址映射关系，那么将根据其设置发起**递归查询或者迭代查询**；

2. 浏览器获得域名对应的IP地址以后，浏览器向服务器请求建立链接，发起三次握手；

3. TCP/IP链接建立起来后，浏览器向服务器发送HTTP请求；

4. 服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器；

5. 浏览器解析并渲染视图，若遇到对js文件、css文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源；

   > 这里值得一提的是，传统http方式是多次请求资源返回资源的过程
   >
   > 而在最新的http/2标准中，资源可以在一次请求页面后，以推送的手段推送给客户端。（因此现在说http是拉协议有待商榷）

6. 浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。



### HTTP请求中的常见状态码

1. 2xx状态码：操作成功。200 OK
2. 3xx状态码：重定向。301 永久重定向；302暂时重定向
3. 4xx状态码：客户端错误。400 Bad Request；401 Unauthorized；403 Forbidden；404 Not Found；
4. 5xx状态码：服务端错误。500服务器内部错误；501服务不可用



### 什么是RIP协议（Routing Information Protocol，距离矢量路由协议）？

每个路由器将维护一张表，记录从该路由器到其他网络的**跳数**(hop count)

路由器到与其直连的网络跳数为1，没经过一个路由器**跳数+1**

更新该表时和相邻的路由器交换信息

允许一个路径最多包含15个路由器，16则表明不可达（规定）

直到所有路由器路由表稳定后，我们称其为**收敛状态**

> RIP是基于UDP的应用层协议

pros&cons：

1. 实现简单，开销小
2. 随着网络规模扩大，开销增大
3. 最大距离是15，网络规模受限
4. “坏消息传的慢”，当网络出现故障时，经过较长的时间才能传递故障消息到所有路由器



