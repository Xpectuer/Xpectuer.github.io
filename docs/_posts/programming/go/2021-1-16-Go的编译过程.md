---
layout: post
title: "Go的编译过程"
tags: programming go compiler
categories: go
---
# 【学习笔记】Go的编译过程

##### 前导知识：编译原理、计算机组成原理

## 几个概念

### AST抽象语法树（Abstract Syntax Tree）

为了消除代码中无用的注释、空格等符号，编译器的主流方法是将代码的**语法元素**以树的形式存储起来

对于表达式``a*b+c``，可以表示为：

```
    +
   / \
  *   c
 /\
a  b
```

## 静态单赋值（Static Single Assignment，SSA）

中间表示（Intermediate Representation，IR）：编译器或虚拟机（这里特指java虚拟机一类的虚拟机），使用的内部代码或数据结构，它可以用来做一些**编译优化**后生成**更高效的目标代码**。

> A "good" IR must be *accurate* – capable of representing the source code without loss of information – and *independent* of any particular source or target language

静态单赋值是GO语言的中间代码的一种特性

对于任何具有这种特性的中间代码，每个变量只会被赋值一次。

以下实例将展示SSA生成的中间代码的效果:

```go
x := 1
x := 2
y := x
```

经过简单的分析，可以发现第一行代码是无用的。

因此，我们通过用**下标实现**SSA的方式来对这段程序进行优化：

```
x_1 = 1
x_2 = 2
y_1 = x_2
```

生成机器码时，编译器可以轻松的发现``x_1``与后面的代码执行没有任何关系，便可以在生成机器码时省略``x:=1``的赋值，通过减少需要执行的指令优化这段代码。



### 指令集

macos在命令行输入``uname -m`` 即可查看当前机器的架构信息。

对于指令集，大概可以分为两类：

- CISC复杂指令集：通过增加指令的类型减少需要执行的指令数。
- RISC精简指令集：通过使用更少的指令类型完成目标的计算任务。

## 编译原理
编译原理的四个阶段：
- 词法分析、语法分析
- 类型检查
- AST语义树转换成中间代码、SSA生成（静态单赋值）,即编译优化阶段
- 生成机器码``0101010``

### 词法和语法分析

#### 词法分析 lexical analysis
所有的编译过程都是从解析源代码开始的，词法分析(lexical analysis),其作用就是就是解析源代码文件，将文件中的字符串序列转换成Token序列，方便后面的处理和解析。

#### 语法分析 syntactic analysis
语法分析输入的是词法分析输出的Token序列，语法分析会按照顺序解析Token序列，该过程会将词法分析生成的Token按照编程语言定义好的**语法**，被归纳成一个SourceFile结构参照[Go语言规范](https://golang.org/ref/spec#Source_file_organization)：
```go
SourceFile = PackageClause ";" { ImportDecl ";" } { TopLevelDecl ";" } .
```  


- 词法分析器会返回一个不包含空格、换行符的Token序列

```json
"json.go": SourceFile {
    "PackageName": "json",
    "ImportDecl": []"Import"{
        "io"
    },
    "TopLevelDecl": "..."
}
```
- 语法分析器将上述词法分析器产生的Token序列，转化成抽象语法书AST，
  每个AST对应单独的Go语言文件，AST中将会包含
  - 当前文件的包名(package)
  - 定义的常量(const)
  - 结构体(struct)
  - 函数(func)
  - ...
 - 语法分析器还会检查源文件中的**语法错误**，并将消息打印到标准输出，然后中止编译过程

### 类型检查
类型检查的将在语法分析完成后进行，
编译器将对语法分析器输出的AST进行分析：
  1. 常量、类型和函数名及类型
  2. 变量和赋值和初始化
  3. 函数和闭包``{}``的主体
  4. 哈希键值对的类型（map类型的key**不能是引用类型**）
  5. 导入函数体
  6. 外部的声明

要做到如上几点，我们只需要遍历整棵AST即可
我们对当前子树的类型进行验证操作，所有的类型错误和不匹配将在这个阶段被暴露出来，包括**结构体对于接口的实现**。

这边要提到一些go语言的特色，比如
``make()``方法，它将在这个阶段根据其被传入的类型，被展开成
```go
runtime.makechan()
runtime.makeslice()
runtime.makemap()
```
等工厂方法

### 中间代码生成
在得到了语法分析器解析并通过类型检查后的AST被 ``cmd/compile/internal/gc.compileFunctions``
我们知道go有go程（goroutine），而编译过程则是多个go程消费带锁队列（存放各个函数的AST）的**并发过程**
```
functions AST --> |  ASTs Queue | --> multiple Goroutines
```
因此，go的中间代码的编译过程，是并发进行的。

### 机器码生成阶段

