---
layout: post
title: "Go的原生Context机制"
categories: go并发编程 
tags: go 并发
date: 2021-02-21
author: noobi
---
<!-- 
# Golang的原生Context -->

> 相信大佬们（~~真的会有大佬来看我吗？~~）看到标题已经懂了，“原生”意味着实际上有许多野生的实现用于不同各自的领域，比如Gin的Context，这里就当作抛砖引玉了。

context是golang除了channel、goroutine的又一**独特机制**。

Golang的context机制被定义于``context.Context`` 中。

### 用途

1. 设置截止日期
2. 设置同步信号
3. 传递请求相关值的结构体

### 1. 组成

#### 1.1 context.Context接口

~~~go
type Context interface {
  // 返回工作截止时间
	Deadline() (deadline time.Time, ok bool)
  // 返回一个channel，在当前工作完成或者context被取消后关闭（并广播）
	Done() <-chan struct{}
  // 返回context.Context结束的原因，仅在Done()方法对应的channel关闭时返回非空的值
  // 1. 被取消，则返回Canceled错误
  // 2. 超时，返回DeadlineExceeded错误
	Err() error
  // 从context.Context获得共享数据的值（有点像session的实现机制）
	Value(key interface{}) interface{}
}
~~~

#### 1.2 context包中的方法罗列

~~~go
func Background() Context
func TODO() Context
func WithValue(parent Context, key, val interface{}) Context
~~~



### 2. Context的设计需求

``Context``的最大作用，就是同步复杂的goroutine树的goroutine**协同与信号处理问题**。

比如以下代码

```
go func() {
	for i:=0; i < 3 ;i++ {
		go func(){
			go func() {}()
		}()
	}
}()
```

会产生这样的树形结构：

![root](/assets/goConcurrency/root.png)

更加实际的场景可能是这样的：



![app](/assets/goConcurrency/app.png)

上图的业务结构中，可能存在一下的场景：

1. 假设我现在有一个存session的需求，需要在不同的request，也就是goroutine之间建立一个**共享的空间**。

​       可以利用``context.Context``这样的一个数据结构的**键值KV存储**来做。

2. 现在需要设计一个数据库的客户端，在数据库成功连接后，通知上层的request handler层对数据进行处理。

   通知就可以用**信号**实现。

3. 我需要设计一个全局的中间件，来做统一的对象验证。如何解耦handler与中间件？

   可以利用context的共享特性进行解耦

4. 如果服务器需要进行Graceful Termination，在下游的数据库客户端需要及时被通知并停止。



无论怎样，Context要做的，就是**将goroutine的协作通道和共享空间打通，相对于手动写锁、写channel、处理错误同步信号，减少了编程的复杂度。**



### 3. Context的设计原理

#### 3.1 信号同步

#### 不求同年同月生，但求同年同月同日死

假设某个工作日的早晨，公司规定九点半打卡，你像往常一样在楼下等你的女朋友一起上班。

然而这天你的女朋友不知为何，梳妆打扮的时间比往日要长。

一边是上班即将迟到，一边是女朋友无限的拖延。

你该怎么办？



如果让屏幕前的你来想这个问题，第一反应是什么呢？

最简单的，就是掐着时间，等到九点钟，预留30分钟的脚程，直接走人。

> 注意⚠️：现实中千万不要如此操作，除非双方达成共识



两个父子goroutine，在不同时间被创建出来，但是需要同时结束并释放，减少资源浪费。

我们可以为context设定超时阈，暴力同步goroutine

~~~go
	ctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)

~~~

有什么场景？

比如我们需要设计一个数据库客户端，每个连接实例作为一个goroutine，但是网络状况无法预测，我们不能让连接反复重试而不释放，需要一个**超时机制**来防止上述情况。

#### 样例

~~~go
func TestSample(t *testing.T) {
	ctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)
  // cancel()广播触发context.Done()返回的channel的关闭
	defer cancel()
	// 起一个goroutine
	go handle(ctx, 500*time.Millisecond)
	select {
    // 订阅ctx.Done()等待cancel()广播信号
	case <-ctx.Done():
		fmt.Println("main", ctx.Err())
	}
}

func handle(ctx context.Context, duration time.Duration) {
	select {
     // 错误分支，订阅ctx.Done()等待cancel()广播信号
	case <-ctx.Done():
		fmt.Println("handle", ctx.Err())
    // 模拟数据库连接与重试的过程
	case <-time.After(duration):
		fmt.Println("process request with", duration)
	}
}
~~~

以上样例（来自于《面向信仰编程》）供读者自行测试体会。



### 3.2 默认上下文

>  很多时候人们并不喜欢做选择，因为一套配置可以解决90%的问题。

``context.Background()``与``context.TODO()``就为我们解决了90%的问题，虽然有些夸张，但是其常用程度毋庸置疑。

```go
func Background() Context {
	return background
}

func TODO() Context {
	return todo
}
```

这两个返回值是两个包内的私有变量

它们如此初始化

```go
var (
	background = new(emptyCtx)
	todo       = new(emptyCtx)
)
```

而``emptyCtx``，实际上就是空的指针类型，并实现了``Context``所有接口方法，这里不展开源码，有兴趣的读者可以自行前往观摩。

至此，所谓的"90%的问题”的本质就是**四大皆空**，因为我们在大部分情况下不存在对于Context的定制需求，我们只需要将``context.Background()``作为参数传入占位符号使用。



### 3.3 取消信号

``context.WithCancel``

从函数名就可以看出来，这是一种工厂方法。

那么我们就抽丝剥茧，一层层看其中的实现

首先暴露了主要的数据结构

~~~go
	c := newCancelCtx(parent)
~~~

我们step in

~~~go
func newCancelCtx(parent Context) cancelCtx {
	return cancelCtx{Context: parent}
}
~~~

再看看``cancelCtx``的结构

```go
// A cancelCtx can be canceled. When canceled, it also cancels any children that implement canceler.
// 为上下文提供被cancel的能力。也就说，当父协程被取消，就会像多米诺骨牌一般取消子协程（其本质就是调用子协程各自注册的cancel方法）
type cancelCtx struct {
  // 组合接口
	Context
	// 一个上下文实例共享一个互斥锁，保护以下共享资源
	mu       sync.Mutex            // protects following fields
  // 懒加载，因为不是刚开始就需要，并且仅仅传递取消的信号，体量较小
	done     chan struct{}         // created lazily, closed by first cancel call
  // 用于注册子协程的cancel方法，比如 数据库客户端的cancel、request handler的cancel等等
	children map[canceler]struct{} // set to nil by the first cancel call
  // 第一个cancel被调用时，记录错误信息
	err      error                 // set to non-nil by the first cancel call
}
```

我将中解释嵌入了注释中，不过更推荐阅读原注释。



这段调用建立起父子上下文关系（初始化上述数据结构的许多变量）：

```go
propagateCancel(parent, &c)
```

~~~go
func propagateCancel(parent Context, child canceler) 
~~~

此函数的主要行为无非三种情况：

1. ``parent.Done()==nil``，即``parent``不触发取消事件，当前的函数直接返回

   ```go
   done := parent.Done()
   	if done == nil {
   		return // parent is never canceled
   	}
   ```

   

2. 当``child``以及``child``的子节点存在可以被取消的上下文时，会判断``parent``是否触发了取消信号：

   1. 如果被取消，``child``则会立刻取消

      ~~~go
      case <-done:
      		// parent is already canceled
      		child.cancel(false, parent.Err())
      		return
      ~~~

      

   2. 如果没有被取消，``child``加入``parent``的``children``列表中，等待``parent``释放取消信号

   ```go
   if p.err != nil {
   			// parent has already been canceled
   			child.cancel(false, p.err)
   		} else {
   			if p.children == nil {
   				p.children = make(map[canceler]struct{})
   			}
   			p.children[child] = struct{}{}
   		}
   ```

3. 为开发者自定义父上下文提供hook。

实际上，``context.propagateCancel``方法是父子建立关系和同步取消和结束信号的核心方法。

这就保证了父协程的退出，不会让子协程继续运行，并且有机会释放资源（实现好的线程安全的cancel方法）。

这也是实现 ``WithDeadline``的Context的基础，为了可以取消，需要复用这个方法。



### 3.4 传值方法

父子上下文需要传递，兄弟上下文需要共享。

这就是对应了上文所讲的session需求。

这部分的实现比较简单，只包括简单的值判断、类型判断。

推荐自行阅读源码。



### 提醒

> 在真正使用传值的功能时我们也应该非常谨慎，使用 [`context.Context`](https://draveness.me/golang/tree/context.Context) 进行传递参数请求的所有参数一种非常差的设计，比较常见的使用场景是传递请求对应用户的认证令牌以及用于进行分布式追踪的请求 ID。

> Gin框架的context与本文的context实现不同，是context的另行实现

### REF

《面向信仰编程-Go语言设计与实现》 - [draveness.me](https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-context/#fn:2) （据说是K8S的contributor）

